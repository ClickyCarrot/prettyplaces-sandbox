<!DOCTYPE html>
<html lang="en">
	<head>
		<!-- Google tag (gtag.js) -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-L5W28XQPSW"></script>
		<script>
			window.dataLayer = window.dataLayer || [];
			function gtag() {
				dataLayer.push(arguments);
			}
			gtag("js", new Date());
			gtag("config", "G-L5W28XQPSW");
		</script>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<script>
			(function () {
				const path = window.location.pathname;
				if (/\/index\.html$/.test(path)) {
					const newPath = path.replace(/\/index\.html$/, "");
					window.location.replace(newPath + window.location.search + window.location.hash);
				}
			})();
		</script>
		<link rel="icon" type="image/svg+xml" href="../../favicon.svg" />
		<title>Tetris Game</title>
		<style>
			body {
				margin: 0;
				padding: 20px;
				background: #0f172a;
				color: #f1f5f9;
				font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
				display: flex;
				flex-direction: column;
				align-items: center;
				min-height: 100vh;
			}
			.game-container {
				text-align: center;
			}
			h1 {
				margin-bottom: 20px;
				color: #8b5cf6;
			}
			.game-wrapper {
				display: flex;
				gap: 20px;
				justify-content: center;
				align-items: flex-start;
			}
			#gameCanvas {
				border: 2px solid #8b5cf6;
				background: #1e293b;
				border-radius: 8px;
				max-width: 100%;
				height: auto;
			}
			.info-panel {
				display: flex;
				flex-direction: column;
				gap: 15px;
			}
			.score-info {
				background: #1e293b;
				padding: 15px;
				border-radius: 8px;
				border: 2px solid #8b5cf6;
				min-width: 150px;
			}
			.score-info h3 {
				margin: 0 0 10px 0;
				color: #8b5cf6;
			}
			.score-info p {
				margin: 5px 0;
				color: #cbd5e1;
			}
			.controls {
				margin-top: 20px;
				color: #cbd5e1;
			}
			a.btn-back {
				display: inline-block;
				margin-top: 20px;
				padding: 10px 20px;
				background: var(--primary-color, #8b5cf6);
				color: white;
				text-decoration: none;
				border-radius: 5px;
				transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease;
				box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
			}
			a.btn-back:hover {
				background: var(--secondary-color, #7c3aed);
				transform: translateY(-3px);
				box-shadow: 0 6px 20px rgba(139, 92, 246, 0.5);
			}
			a.btn-back:active {
				transform: translateY(-1px);
				box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
			}
		</style>
	</head>
	<body>
		<div class="game-container">
			<h1>üß© Tetris</h1>
			<div class="game-wrapper">
				<canvas id="gameCanvas" width="300" height="600"></canvas>
				<div class="info-panel">
					<div class="score-info">
						<h3>Score</h3>
						<p id="score">0</p>
						<h3>Lines</h3>
						<p id="lines">0</p>
						<h3>Level</h3>
						<p id="level">1</p>
					</div>
				</div>
			</div>
			<div class="controls">
				<p>Use WASD to move (W=up, A=left, S=down, D=right). Q to rotate. Space to drop!</p>
			</div>
			<a href="/" class="btn-back">‚Üê Back to Game Hub</a>
		</div>

		<script src="../../theme-loader.js"></script>
		<script src="../../cloaking.js"></script>
		<script>
			// Tetris Game
			const canvas = document.getElementById("gameCanvas");
			const ctx = canvas.getContext("2d");
			const blockSize = 30;
			const cols = 10;
			const rows = 20;

			let board = [];
			let score = 0;
			let lines = 0;
			let level = 1;
			let dropCounter = 0;
			let dropInterval = 1000;
			let lastTime = 0;

			// Initialize board
			for (let y = 0; y < rows; y++) {
				board[y] = [];
				for (let x = 0; x < cols; x++) {
					board[y][x] = 0;
				}
			}

			// Tetris pieces (shapes)
			const pieces = [
				[
					[0, 0, 0, 0],
					[1, 1, 1, 1],
					[0, 0, 0, 0],
					[0, 0, 0, 0],
				],
				[
					[1, 1],
					[1, 1],
				],
				[
					[0, 1, 0],
					[1, 1, 1],
					[0, 0, 0],
				],
				[
					[0, 1, 1],
					[1, 1, 0],
					[0, 0, 0],
				],
				[
					[1, 1, 0],
					[0, 1, 1],
					[0, 0, 0],
				],
				[
					[1, 0, 0],
					[1, 1, 1],
					[0, 0, 0],
				],
				[
					[0, 0, 1],
					[1, 1, 1],
					[0, 0, 0],
				],
			];

			const colors = [
				"#000000",
				"#8b5cf6",
				"#ec4899",
				"#6366f1",
				"#10b981",
				"#f59e0b",
				"#ef4444",
				"#06b6d4",
			];

			let player = {
				pos: { x: 0, y: 0 },
				matrix: null,
				score: 0,
			};

			function createPiece(type) {
				const piece = JSON.parse(JSON.stringify(pieces[type]));
				// Assign color index (1-7) to each block
				const colorIndex = type + 1;
				for (let y = 0; y < piece.length; y++) {
					for (let x = 0; x < piece[y].length; x++) {
						if (piece[y][x] !== 0) {
							piece[y][x] = colorIndex;
						}
					}
				}
				return piece;
			}

			function playerReset() {
				const pieceType = Math.floor(Math.random() * pieces.length);
				player.matrix = createPiece(pieceType);
				player.pos.y = 0;
				player.pos.x = ((cols / 2) | 0) - ((player.matrix[0].length / 2) | 0);

				if (collide(board, player)) {
					// Game over
					board.forEach((row) => row.fill(0));
					score = 0;
					lines = 0;
					level = 1;
					dropInterval = 1000;
					updateDisplay();
				}
			}

			function collide(board, player) {
				const [m, o] = [player.matrix, player.pos];
				for (let y = 0; y < m.length; ++y) {
					for (let x = 0; x < m[y].length; ++x) {
						if (m[y][x] !== 0) {
							const boardY = y + o.y;
							const boardX = x + o.x;
							if (
								boardY < 0 ||
								boardY >= rows ||
								boardX < 0 ||
								boardX >= cols ||
								(board[boardY] && board[boardY][boardX] !== 0)
							) {
								return true;
							}
						}
					}
				}
				return false;
			}

			function merge(board, player) {
				player.matrix.forEach((row, y) => {
					row.forEach((value, x) => {
						if (value !== 0) {
							if (
								board[y + player.pos.y] &&
								board[y + player.pos.y][x + player.pos.x] !== undefined
							) {
								board[y + player.pos.y][x + player.pos.x] = value;
							}
						}
					});
				});
			}

			function playerRotate() {
				const pos = player.pos.x;
				let offset = 1;
				rotate(player.matrix, -1);
				while (collide(board, player)) {
					player.pos.x += offset;
					offset = -(offset + (offset > 0 ? 1 : -1));
					if (offset > player.matrix[0].length) {
						rotate(player.matrix, 1);
						player.pos.x = pos;
						return;
					}
				}
			}

			function rotate(matrix, dir) {
				for (let y = 0; y < matrix.length; ++y) {
					for (let x = 0; x < y; ++x) {
						[matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
					}
				}
				if (dir > 0) {
					matrix.forEach((row) => row.reverse());
				} else {
					matrix.reverse();
				}
			}

			function boardSweep() {
				let rowCount = 1;
				let sweepScore = 0;
				outer: for (let y = board.length - 1; y > 0; --y) {
					for (let x = 0; x < board[y].length; ++x) {
						if (board[y][x] === 0) {
							continue outer;
						}
					}
					const row = board.splice(y, 1)[0].fill(0);
					board.unshift(row);
					++y;
					lines += rowCount;
					sweepScore += rowCount * 10;
					rowCount *= 2;
				}
				score += sweepScore;
				level = Math.floor(lines / 10) + 1;
				dropInterval = Math.max(100, 1000 - (level - 1) * 50);
				updateDisplay();
			}

			function playerDrop() {
				player.pos.y++;
				if (collide(board, player)) {
					player.pos.y--;
					merge(board, player);
					playerReset();
					boardSweep();
				}
				dropCounter = 0;
			}

			function playerMove(dir) {
				player.pos.x += dir;
				if (collide(board, player)) {
					player.pos.x -= dir;
				}
			}

			function draw() {
				ctx.fillStyle = "#1e293b";
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				drawBoard(board);
				drawMatrix(player.matrix, player.pos);
			}

			function drawBoard(board) {
				for (let y = 0; y < rows; y++) {
					for (let x = 0; x < cols; x++) {
						if (board[y][x] !== 0) {
							ctx.fillStyle = colors[board[y][x]];
							ctx.fillRect(x * blockSize, y * blockSize, blockSize - 2, blockSize - 2);
						}
					}
				}
			}

			function drawMatrix(matrix, offset) {
				matrix.forEach((row, y) => {
					row.forEach((value, x) => {
						if (value !== 0) {
							ctx.fillStyle = colors[value];
							ctx.fillRect(
								(x + offset.x) * blockSize,
								(y + offset.y) * blockSize,
								blockSize - 2,
								blockSize - 2
							);
						}
					});
				});
			}

			function updateDisplay() {
				document.getElementById("score").textContent = score;
				document.getElementById("lines").textContent = lines;
				document.getElementById("level").textContent = level;
			}

			function update(time) {
				const deltaTime = time - lastTime;
				lastTime = time;

				if (deltaTime > 0) {
					dropCounter += deltaTime;
					if (dropCounter > dropInterval) {
						playerDrop();
						dropCounter = 0;
					}
				}

				draw();
				requestAnimationFrame(update);
			}

			document.addEventListener("keydown", (e) => {
				const key = e.key.toLowerCase();
				if (key === "a") {
					playerMove(-1);
				} else if (key === "d") {
					playerMove(1);
				} else if (key === "s") {
					playerDrop();
				} else if (key === "w") {
					player.pos.y--;
					if (collide(board, player)) {
						player.pos.y++;
					}
				} else if (key === "q") {
					playerRotate();
				} else if (key === " ") {
					e.preventDefault();
					while (!collide(board, player)) {
						player.pos.y++;
					}
					player.pos.y--;
					playerDrop();
				}
			});

			playerReset();
			updateDisplay();
			lastTime = performance.now();
			requestAnimationFrame(update);
		</script>
	</body>
</html>
